# Code Generated by ZenTest v. 3.11.1

require 'test/unit' unless defined? $ZENTEST and $ZENTEST

$:.unshift File.dirname(__FILE__) + "/../lib" 
require 'relisp'
require 'tempfile'

class Tempfile
  @@counter = 0

  def self.new_path(name = 'tempfile')
    file = Tempfile.new(name)
    file.close
    @@counter += 1
    # The extra counter is to prevent two instances of emacs both
    # working with the same file.
    return file.path + @@counter.to_s
  end
end

EMACS = Relisp::ElispSlave.new unless defined? EMACS

module TestRelisp
  class TestProxy < Test::Unit::TestCase
    def setup
      @emacs = EMACS
    end
  
    def test_class_from_elisp
      test_buffer_name = "*relisp-test-buffer*"
      buffer = @emacs.elisp_eval( "(create-file-buffer \"#{test_buffer_name}\") " )
      assert_kind_of Relisp::Buffer, buffer
      buffer_names = @emacs.elisp_eval( '(buffer-list)' ).to_list.map { |b| b.name } 
      assert buffer_names.include?(test_buffer_name)
    end

    # This is really tested in all of the other classes.
    def test_initialize
      new_buffer = Relisp::Buffer.new("new-buffer")
      assert_kind_of Relisp::Buffer, new_buffer
      assert_equal "new-buffer", new_buffer.name
    end

    def test_to_elisp
      test_buffer_name = "*relisp-test-buffer*"
      buffer = @emacs.elisp_eval( "(create-file-buffer \"#{test_buffer_name}\") " )
      assert_equal :buffer, @emacs.elisp_eval("(type-of #{buffer.to_elisp})")
    end
  end


  class TestBuffer < Test::Unit::TestCase

    def setup
      @emacs = Relisp::ElispSlave.new
      @buffer = Relisp::Buffer.new "*relisp-setup-test-buffer*"
    end

    def test_class_from_elisp
      test_buffer_name = "*relisp-test-buffer*"
      buffer = @emacs.elisp_eval( "(create-file-buffer \"#{test_buffer_name}\") " )
      assert_kind_of Relisp::Buffer, buffer
      buffer_names = @emacs.elisp_eval( '(buffer-list)' ).to_list.map { |b| b.name } 
      assert buffer_names.include?(test_buffer_name)
    end

    def test_initialize
      new_buffer = Relisp::Buffer.new("new-buffer")
      assert_kind_of Relisp::Buffer, new_buffer
      assert_equal "new-buffer", new_buffer.name
      found_buffer = @emacs.get_buffer(new_buffer.name)
      assert_kind_of Relisp::Buffer, found_buffer
    end

    def test_to_elisp
      test_buffer_name = "*relisp-test-buffer*"
      buffer = @emacs.elisp_eval( "(create-file-buffer \"#{test_buffer_name}\") " )
      assert_equal :buffer, @emacs.elisp_eval("(type-of #{buffer.to_elisp})")
    end

    def test_set
      b1_name = "*relisp-test-buffer1*"
      b2_name = "*relisp-test-buffer2*"
      b1 = Relisp::Buffer.new b1_name
      b2 = Relisp::Buffer.new b2_name
      
      b1.set
      assert_equal b1_name, @emacs.buffer_name
      b2.set
      assert_equal b2_name, @emacs.buffer_name
    end

    def test_name
      test_buffer_name = "*relisp-test-buffer*"
      buffer = @emacs.elisp_eval( "(create-file-buffer \"#{test_buffer_name}\") " )
      assert_equal test_buffer_name, buffer.name
    end

    def test_rename
      b = Relisp::Buffer.new "*relisp-test-buffer*"
      assert_equal b.name, "*relisp-test-buffer*"
      b.insert "this text should stay here"
      text = b.to_s
      b.rename "*same-relisp-buffer*"
      assert_equal b.name, "*same-relisp-buffer*"
      assert_equal text, b.to_s
    end

    def test_filename
      file = Tempfile.new_path
      assert_nil @buffer.filename
      @buffer.filename = file
      assert_equal file, @buffer.filename
    end

    def test_filename_equals
      # test_filename
    end

    def test_modified_eh
      file = Tempfile.new_path
      assert ! @buffer.modified?
      @buffer.insert "some text"
      assert @buffer.modified?
      @buffer.filename = file
      @buffer.save
      assert ! @buffer.modified?
    end

    def test_set_modified
      file = Tempfile.new_path
      assert ! @buffer.modified?
      @buffer.set_modified
      assert @buffer.modified?
      @buffer.filename = file
      @buffer.save
      assert ! @buffer.modified?
      @buffer.insert "some text"
      @buffer.set_modified(false)
      assert ! @buffer.modified?
    end

    def test_modified_equals
      file = Tempfile.new_path
      assert ! @buffer.modified?
      @buffer.modified = true
      assert @buffer.modified?
      @buffer.filename = file
      @buffer.save
      assert ! @buffer.modified?
      @buffer.insert "some text"
      @buffer.modified = false
      assert ! @buffer.modified?
    end

    def test_buffer_modified_tick
      @buffer.insert "arokfv "
      assert_equal 2, @buffer.modified_tick
    end

    def test_chars_modified_tick
      @buffer.insert "arokfv "
      assert_equal 2, @buffer.chars_modified_tick
    end

    def test_read_only_eh
      assert ! @buffer.read_only?
      @buffer.read_only=true
      assert @buffer.read_only?
    end

    def test_read_only_equals
      assert ! @buffer.read_only?
      @buffer.read_only=true
      assert @buffer.read_only?
      assert_raise Relisp::ElispError do
        @buffer.insert "A"
      end
      @buffer.read_only=false
      assert ! @buffer.read_only?
    end

    def bury
      buffer = Relisp::Buffer.new('a')
      assert_kind_of Relisp::Window, buffer.window
      buffer.bury
      assert_nil buffer.window
    end

    def test_kill
      assert @emacs.buffer_list.to_list.map {|b| b.name}.include?(@buffer.name)
      @buffer.insert "a"
      assert_raise RuntimeError do
        @buffer.kill
      end
      @buffer.modified=false
      @buffer.kill
      assert ! @emacs.buffer_list.to_list.map {|b| b.name}.include?(@buffer.name)
    end

    def test_kill_bang
      assert @emacs.buffer_list.to_list.map {|b| b.name}.include?(@buffer.name)
      @buffer.insert "a"
      assert @buffer.modified?
      assert_nothing_raised do
        @buffer.kill!
      end
    end

    def test_alive_eh?
      assert @buffer.alive?
      @buffer.kill!
      assert ! @buffer.alive?
    end

    def test_save
      string = "text to write to file"
      @buffer << string
      assert_raises RuntimeError do
        @buffer.save
      end
      file = Tempfile.new_path
      @buffer.filename = file
      @buffer.save
    end

    def test_write
      file = Tempfile.new_path
      string = "text to write to file"
      @buffer.insert string
      @buffer.write(file)
      assert ! @buffer.modified?
      assert_equal file, @buffer.filename
    end

    def test_size
      assert_equal 0, @buffer.size
      @buffer.insert "12345"
      assert_equal 5, @buffer.size
    end

    def test_substring
      @buffer.insert "abcde"
      assert_equal "bc", @buffer.substring(2,4)
    end

    def test_substring_no_properties
      # TODO: not really testing the "no properties" bit
      @buffer.insert "abcde"
      assert_equal "bc", @buffer.substring_no_properties(2,4)
    end

    def test_to_s
      assert_equal "", @buffer.to_s
      @buffer.insert "Some text"
      @buffer.insert "another line"
      assert_equal @buffer.to_s, "Some textanother line"
    end

    def test_erase
      @buffer.insert "Some text"
      assert_equal @buffer.to_s, "Some text"
      @buffer.erase
      assert_equal @buffer.to_s, ""
    end

    def test_window
      @emacs.switch_to_buffer(@buffer)
      assert_kind_of Relisp::Window, @buffer.window
    end

    def test_insert
      # TODO: test that objects besides Strings are inserted correctly
    end

    def test_puts
      @buffer.puts   "abc"
      @buffer.insert "def"
      assert_equal "abc\ndef", @buffer.to_s
    end

    def test_append
      @buffer.insert "abc"
      @buffer.set
      @emacs.goto_char(@emacs.point_min)
      assert_equal 1, @emacs.point
      @buffer << "def"
      assert_equal "abcdef", @buffer.to_s
    end

  end

  class TestMarker < Test::Unit::TestCase
    def setup
      @emacs = EMACS
#      @emacs = Relisp::ElispSlave.new
    end

    def test_class_from_elisp
      assert_kind_of Relisp::Marker, @emacs.point_marker
      assert @emacs.elisp_eval( "(equal #{@emacs.point_marker.to_elisp} (point-marker))" )
      assert_kind_of Relisp::Marker, Relisp::Marker.new
    end

    def test_to_elisp
      assert_equal :marker, @emacs.elisp_eval( "(type-of #{@emacs.point_marker.to_elisp})" )
    end

    def test_position
      marker = Relisp::Marker.new
      assert_nil marker.position
      # see test_set
    end

    def test_buffer
      marker = Relisp::Marker.new
      assert_nil marker.buffer
      # see test_set
    end

    def test_insertion_type
      marker = Relisp::Marker.new
      assert_nil marker.insertion_type
      marker.insertion_type=true
      assert marker.insertion_type      
    end

    def test_set
      marker = Relisp::Marker.new(@emacs)
      buffer = Relisp::Buffer.new(@emacs)
      marker.set(1, buffer.to_elisp)
      assert_equal buffer, marker.buffer
      assert_equal 1, marker.position
    end

  end

  class TestWindow < Test::Unit::TestCase
    @@emacs = EMACS

    def setup
      @emacs = @@emacs
#      @emacs = Relisp::ElispSlave.new
    end

    def test_class_from_elisp
      assert_kind_of Relisp::Window, @emacs.selected_window
    end

    def test_split
      window = @emacs.selected_window
      window.delete_others
      window.split
      assert_equal 2, @emacs.window_list.to_list.size
    end

    def test_horizontally
      window = @emacs.selected_window
      window.delete_others
      old_width = window.width
      begin
        window.split_horizontally
        assert old_width > window.width
      rescue Relisp::ElispError => dag_yo
        assert dag_yo.to_s =~ /width/
      end
    end

    def test_vertically
      window = @emacs.selected_window
      window.delete_others
      old_height = window.height
      window.split_vertically
      assert old_height > window.height
    end

    def test_alive_eh
      window = @emacs.selected_window.split
      window.delete
      assert ! window.alive?
    end

    def test_delete_others
      window = @emacs.selected_window
      window.delete_others
      window.split
      assert @emacs.window_list.to_list.size > 1
      window.delete_others
      assert_equal 1, @emacs.window_list.to_list.size
    end

    def test_select
      w1 = @emacs.selected_window
      w1.delete_others
      w2 = w1.split
      w1.select
      assert_equal @emacs.selected_window, w1
      w2.select
      assert_equal @emacs.selected_window, w2
    end

    def test_buffer
      window = @emacs.selected_window
      buffer1 = Relisp::Buffer.new(@emacs)
      buffer2 = Relisp::Buffer.new(@emacs)
      window.buffer=buffer1
      assert_equal buffer1, window.buffer
      window.buffer=buffer2
      assert_equal buffer2, window.buffer
    end

    def test_dedicated
      window = @emacs.selected_window
      assert ! window.dedicated
      window.dedicated = true
      assert window.dedicated
      window.dedicated = nil   
    end

    def test_point
      w1 = @emacs.selected_window
      w1.delete_others
      b = Relisp::Buffer.new(@emacs)
      w1.buffer=b
      assert_equal 1, w1.point
      b.insert "12345"
      w2 = w1.split
      w2.select
      w1.point = 1 # w1 point moves because of insert
      @emacs.goto_char(@emacs.point_max)
      assert_equal 6, @emacs.point
      assert_equal 1, w1.point
      w1.point = 3
      assert_equal 3, w1.point
      assert_equal 6, w2.point
    end

    def test_start
      # TODO: something is weird here.  maybe the visible? function
      # doesn't work in batch mode

      window = @emacs.selected_window 
      window.delete_others
      window.buffer = Relisp::Buffer.new(@emacs)
      assert_equal 1, window.start
      window.buffer.insert "a\n" * window.height * 3
      window.point = @emacs.point_max
      @emacs.elisp_eval("(redisplay)") # Need to refresh the display in
                                      # order to update 'buffer-start'
                                      # and 'buffer-end'--I don't know
                                      # why 'redisplay' doesn't work
                                      # here
#      assert window.start > 1
      assert ! window.visible?(1)
#      @emacs.elisp_eval "(set-window-start (selected-window) 1)"
      window.start = 1

#       @emacs.elisp_eval("(redisplay)")
#       puts window.start
#       puts window.end
#       puts window.buffer.point_max
#       assert window.visible?(181)      
    end

    def test_scroll_up
      window = @emacs.selected_window 
      window.delete_others
      window.buffer.insert "a\n" * window.height * 3
      window.scroll_up
      assert window.start > 1
      window.scroll_down
      assert window.start == 1
    end

    def test_edges
      window = @emacs.selected_window 
      assert_equal 4, window.edges.size
      assert_equal 4, window.inside_edges.size
      assert_equal 4, window.pixel_edges.size
      assert_equal 4, window.inside_pixel_edges.size
    end

    def test_frame
      assert_kind_of Relisp::Frame, @emacs.selected_window.frame
    end
  end

  class TestFrame < Test::Unit::TestCase
    def setup
#      @emacs = Relisp::ElispSlave.new
      @emacs = EMACS
    end

    def test_class_from_elisp
      assert_kind_of Relisp::Frame, @emacs.selected_frame
    end
    
    def test_initialize
      # TODO: causes "unknown terminal type" when run in non-window mode      
      # new_frame = Relisp::Frame.new
      # assert_kind_of Relisp::Frame, new_frame
      # assert_equal :frame,  @emacs.elisp_eval( "(type-of #{new_frame.to_elisp})")
      # new_frame = Relisp::Frame.new({:width => 30, :height => 20})
      # assert_kind_of Relisp::Frame, new_frame
      # assert_equal :frame,  @emacs.elisp_eval( "(type-of #{new_frame.to_elisp})")
    end

    def test_alive_eh
      # TODO: causes "unknown terminal type" when run in non-window mode
      # f = Relisp::Frame.new
      # assert f.alive?
      # f.delete
      # assert ! f.alive?
    end
  end

  class TestWindowConfiguration < Test::Unit::TestCase
    def setup
      @emacs = EMACS
    end

    def test_class_from_elisp
      assert_kind_of Relisp::WindowConfiguration, @emacs.current_window_configuration
    end
  end

  class TestProcess < Test::Unit::TestCase
    def setup
      @emacs = EMACS
    end
    
    def test_class_from_elisp
      assert_kind_of Relisp::Process, @emacs.start_process("test", "test", "ls")
    end

    def test_name
      p = @emacs.start_process("process", "pbuffer", "ls")
      assert_equal 'process', p.name
      sleep 0.5
      assert_equal :exit, p.status
      assert_equal 0, p.exit_status
    end
  end

  class TestOverlay < Test::Unit::TestCase
    def setup
      @emacs = Relisp::ElispSlave.new
    end
    
    def test_class_from_elisp
      @emacs.insert("sometext")
      assert_kind_of Relisp::Overlay,  @emacs.elisp_eval( "(make-overlay 1 3)")
    end

    def test_initialize
      @emacs.insert("sometext")
      new_overlay = Relisp::Overlay.new(1, 3)
      assert_kind_of Relisp::Overlay, new_overlay
      assert_equal :overlay,  @emacs.elisp_eval( "(type-of #{new_overlay.to_elisp})")
    end

    def test_start
      @emacs.insert("sometext")
      o = Relisp::Overlay.new(1, 3)
      assert_equal 1, o.start
      assert_equal 3, o.end
      assert_equal @emacs.current_buffer, o.buffer
      o.move(2,4)
      assert_equal 2, o.start
      assert_equal 4, o.end
      o.start = 1
      o.end = 3
      assert_equal 1, o.start
      assert_equal 3, o.end
      o.delete
      assert_nil o.start
    end

    def test_property
      @emacs.insert("sometext")
      o = Relisp::Overlay.new(1, 3)
      o.priority = 2
      assert_equal 2, o.priority
    end

  end

end

